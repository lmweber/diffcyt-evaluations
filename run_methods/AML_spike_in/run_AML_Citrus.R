##########################################################################################
# Script to run methods
# 
# - method: Citrus
# - data set: AML-spike-in
# 
# Lukas Weber, July 2017
##########################################################################################


library(flowCore)
library(citrus)




################################
# Loop to run for each threshold
################################

# spike-in thresholds (must match filenames)
thresholds <- c("5pc", "1pc", "0.1pc", "0.01pc")

# condition names
cond_names <- c("CN", "CBF")

# lists to store objects
is_spikein_thresholds <- vector("list", length(thresholds))
names(is_spikein_thresholds) <- thresholds




for (th in 1:length(thresholds)) {
  
  ######################################
  # Load data, pre-processing, transform
  ######################################
  
  # ---------
  # load data
  # ---------
  
  # filenames
  files_healthy <- list.files("../../../../benchmark_data/AML_spike_in/data/healthy", 
                              pattern = "\\.fcs$", full.names = TRUE)
  files_CN <- list.files("../../../../benchmark_data/AML_spike_in/data/CN", 
                         pattern = paste0("_", thresholds[th], "\\.fcs$"), full.names = TRUE)
  files_CBF <- list.files("../../../../benchmark_data/AML_spike_in/data/CBF", 
                          pattern = paste0("_", thresholds[th], "\\.fcs$"), full.names = TRUE)
  
  # load data
  files_load <- c(files_healthy, files_CN, files_CBF)
  files_load
  
  d_input <- lapply(files_load, read.FCS, transformation = FALSE, truncate_max_range = FALSE)
  
  # sample IDs, group IDs, block IDs
  sample_IDs <- gsub("(_[0-9]+pc$)|(_0\\.[0-9]+pc$)", "", 
                     gsub("^AML_spike_in_", "", 
                          gsub("\\.fcs$", "", basename(files_load))))
  sample_IDs
  
  group_IDs <- gsub("_.*$", "", sample_IDs)
  group_IDs
  
  block_IDs <- gsub("^.*_", "", sample_IDs)
  block_IDs
  
  # set group_IDs reference level (for differential tests)
  group_IDs <- factor(group_IDs, levels = c("healthy", "CN", "CBF"))
  group_IDs
  
  # check all match correctly
  data.frame(sample_IDs, group_IDs, block_IDs)
  
  # indices of all marker columns, lineage markers, and functional markers
  # (16 surface markers / 15 functional markers; see Levine et al. 2015, Supplemental 
  # Information, p. 4)
  cols_markers <- 11:41
  cols_lineage <- c(35, 29, 14, 30, 12, 26, 17, 33, 41, 32, 22, 40, 27, 37, 23, 39)
  cols_func <- setdiff(cols_markers, cols_lineage)
  
  
  # ------------------------------------------------------
  # remove spike-in indicator columns and store separately
  # ------------------------------------------------------
  
  # 'AML-spike-in' data set includes indicator columns for spike-in cells in conditions
  # 'CN' and 'CBF'; these need to be removed and stored separately
  
  is_spikein_thresholds[[th]] <- vector("list", length(sample_IDs))
  names(is_spikein_thresholds[[th]]) <- sample_IDs
  
  for (i in 1:length(sample_IDs)) {
    exprs_i <- exprs(d_input[[i]])
    if (group_IDs[i] == "healthy") {
      is_spikein_thresholds[[th]][[i]] <- rep(0, nrow(exprs_i))
    } else {
      is_spikein_thresholds[[th]][[i]] <- exprs_i[, "spikein"]
      # remove column from expression matrix
      d_input[[i]] <- flowFrame(exprs_i[, -match("spikein", colnames(exprs_i))])
    }
  }
  
  
  # --------------
  # Transform data
  # --------------
  
  # 'asinh' transform with 'cofactor' = 5 (see Bendall et al. 2011, Supp. Fig. S2)
  
  # note: 'cydar' vignette uses biexponential transform instead (using 'estimateLogicle'
  # function from 'flowCore' package)
  
  cofactor <- 5
  
  d_input <- lapply(d_input, function(d) {
    e <- exprs(d)
    e[, cols_markers] <- asinh(e[, cols_markers] / cofactor)
    flowFrame(e)
  })
  
  
  
  
  ###################################################
  # Export files into one subdirectory per comparison
  ###################################################
  
  for (j in 1:length(cond_names)) {
    
    ix_keep <- group_IDs %in% c("healthy", cond_names[j])
    
    sample_IDs_keep <- sample_IDs[ix_keep]
    files_load_keep <- files_load[ix_keep]
    d_input_keep <- d_input[ix_keep]
    
    for (i in 1:length(sample_IDs_keep)) {
      path <- paste0("../../../Citrus_files/data_transformed/AML_spike_in/", thresholds[th], "/", cond_names[j])
      filename <- file.path(path, gsub("\\.fcs$", "_transf.fcs", basename(files_load_keep[i])))
      write.FCS(d_input_keep[[i]], filename)
    }
  }
  
  
  
  ############
  # Run Citrus
  ############
  
  # using modified code from autogenerated file 'runCitrus.R'
  
  
  for (j in 1:length(cond_names)) {
    
    ix_keep <- group_IDs %in% c("healthy", cond_names[j])
    
    sample_IDs_keep <- sample_IDs[ix_keep]
    group_IDs_keep <- droplevels(group_IDs[ix_keep])
    files_load_keep <- files_load[ix_keep]
    
    
    
    # model type
    family <- "classification"
    
    # directories
    dataDirectory <- paste0("../../../Citrus_files/data_transformed/AML_spike_in/", thresholds[th], "/", cond_names[j])
    outputDirectory <- file.path(dataDirectory, "citrusOutput")
    
    # columns for clustering
    clusteringColumns <- colnames(d_input[[1]])[cols_lineage]
    medianColumns <- NULL
    
    # transformation: already done above
    transformColumns <- NULL
    transformCofactor <- NULL
    
    scaleColumns <- NULL
    
    # parameters
    minimumClusterSizePercent <- 0.01
    
    modelTypes <- "glmnet"
    
    # number of cells from each file
    fileSampleSize <- 5000
    
    nFolds <- 1
    
    # feature type
    featureType <- "abundances"
    
    # files
    fileList <- data.frame(defaultCondition = gsub("\\.fcs$", "_transf.fcs", basename(files_load_keep)))
    labels <- group_IDs_keep
    
    
    results <- citrus.full(
      fileList = fileList, 
      labels = labels, 
      clusteringColumns = clusteringColumns, 
      dataDirectory = dataDirectory, 
      outputDirectory = outputDirectory, 
      family = family, 
      modelTypes = modelTypes, 
      nFolds = nFolds, 
      fileSampleSize = fileSampleSize, 
      featureType = featureType, 
      minimumClusterSizePercent = minimumClusterSizePercent, 
      transformColumns = transformColumns, 
      transformCofactor = transformCofactor, 
      scaleColumns = scaleColumns, 
      medianColumns = medianColumns
    )
    
    # plot results
    #plot(results, outputDirectory)
    
    
    
    
    ##########################
    # Extract and save results
    ##########################
    
    # cell indices from original files are stored in 'res$citrus.combinedFCSSet$data', column 'fileEventNumber';
    # can use 'fileIds', list of filenames, and number of sampled cells per file to match the cells
    
    # differential features are saved in:
    # 'results$conditionRegressionResults$defaultCondition$glmnet$differentialFeatures'
    
    # cell indices in the differential clusters are saved in:
    # 'results$citrus.foldClustering'
    # 'results$citrus.foldClustering$allClustering$clusterMembership'
    # these are in complicated 'hclust' format, which needs to be unpacked
    
    # can find how to get cell indices by looking through following file:
    # https://github.com/nolanlab/citrus/blob/master/R/citrus.plot.R
    
    # cluster marker expression values
    #cluster_ID <- 49939
    #results$citrus.combinedFCSSet$data[results$citrus.foldClustering$allClustering$clusterMembership[[cluster_ID]], clusteringColumns]
    
    # 'ix' contains the indices
    cluster_ID <- 49939
    data <- results$citrus.combinedFCSSet$data
    ix <- results$citrus.foldClustering$allClustering$clusterMembership[[cluster_ID]]
    str(ix)
    length(ix)
    summary(ix)
    
    
    
    
    
    
  }
  
}



